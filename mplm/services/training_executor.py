"""
Executes LLM-generated training/evaluation code.
"""

from typing import Any

from sklearn.model_selection import train_test_split

from ..models.training import TrainExecutionResult
from ..settings import settings
from ..utils.exceptions import CodeExecutionError
from ..utils.fileio import save_pickle
from ..utils.logger import get_logger

logger = get_logger(__name__)


def execute_training_code(
    df,
    code: str,
    model_output_path: str | None = None,
    random_seed: int | None = settings.default_random_seed,
) -> TrainExecutionResult:
    """
    Execute training code generated by LLM.

    Args:
        df: pandas DataFrame
        code: Training code string
        model_output_path: pickle model output filepath
        random_seed: random seed for train/val/test split

    Returns:
        TrainExecutionResult
    """
    df_train_full, df_test = train_test_split(df, test_size=0.2, random_state=random_seed, shuffle=True)
    df_train, df_val = train_test_split(df_train_full, test_size=0.15, random_state=random_seed, shuffle=True)

    # local_vars に分割済みデータフレームを渡す
    local_vars: dict[str, Any] = {
        "df_train": df_train,
        "df_val": df_val,
        "df_test": df_test,
    }

    # logger.info("Executing training code:\n%s", code)

    try:
        exec(code, {}, local_vars)
    except Exception as e:
        logger.error('Error occured when executing generated training code')
        # logger.error(code)
        raise CodeExecutionError(f"Error executing training code: {e}") from e

    accuracy_val = local_vars.get("accuracy_val")
    accuracy_test = local_vars.get("accuracy_test")
    model = local_vars.get("model")

    if model is None:
        raise CodeExecutionError("Training code did not produce model.")
    if accuracy_val is None or accuracy_test is None:
        raise CodeExecutionError("Training code did not produce accuracy_val or accuracy_test.")

    if model_output_path is not None:
        save_pickle(model, model_output_path)
        logger.info(f"Saved model to {model_output_path}")

    return TrainExecutionResult(
        accuracy_val=float(accuracy_val),
        accuracy_test=float(accuracy_test),
        model_path=model_output_path,
        model=model,
        code=code,
        model_name=str(model),
    )
